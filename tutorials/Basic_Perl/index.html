<!--#include virtual="/includes/header_pretitle.inc" -->
<title>GIMP - Basic Perl</title>
<!--#include virtual="/includes/header_posttitle.inc" -->
<div id="main">
<div class="heading">Basic Perl</div>

<div class="subtitle">Intention</div>
<p>
  One of the wonderful features of GIMP is that it all its functionality may be accessed through scripting. 
  So far most of the script programming for Gimp has been done through Scheme through Script-Fu. 
  Unfortunately the Scheme environment Gimp provides is very primitive, e.g. without any reasonable error handling. 
  Furthermore, must users are not familiar with scheme as a language. Some users may therefore prefer to write scripts for the Gimp in Perl.
  <br /><br />
  Perl as a language is probably more familiar to the web-literate users, as it is the major language for writing CGI scripts. 
  Now, Gimp scripts may also be written with Perl. This tutorial will describe how to write such plug-ins and scripts for Gimp.
  <br />
  As there are several excellent tutorial texts describing the perl language, this tutorial will assume at working knowledge of Perl, 
  and will instead concentrate on the use GIMP together with the of the perl modules Gimp and Gimp::Fu, written by Marc Lehmann, <a href="mailto:pcg@goof.com">pcg@goof.com</a>
</p>

<div class="subtitle">1. What You Need</div>
<p>
  The Perl::Gimp tutorial scripts have been tested with the following versions:
</p>
<ol>
  <li>Gimp version 1.2 or later, with all its prerequisites.</li>
  <li>Perl version 5.005 or later.</li>
  <li>The perl module Gtk, version 0.7003</li>
  <li>The Gimp module, version 1.201 or later</li>
</ol>
<p>
  Perl and all its associated modules are available in source form from the Perl Comprehensive Archive network, CPAN. 
  It is also possible to download them in RPM format from the ftp.gimp.org website.
</p>

<div class="subtitle">2. The Gimp module</div>
<p>
  Most scripts make use of the simplified interface Gimp::Fu provided with the Gimp module. 
  Gimp::Fu provides a framework for entering parameters to the script in a frame like interface, 
  just like Script-Fu, but also allows running of the script in batch mode from the command line. 
  This tutorial will go into detail descriptions of the construction of a Gimp::Fu script, but before we do this, 
  here is the general framework of a Perl-Fu script.
</p>
<div class="code">
<br />
  #!/usr/local/bin/perl 
  use Gimp ":auto"; 
  use Gimp::Fu;
  # Register extension to gimp
  register ... ;
  exit main();  # Handle over control to gimp 
  <br />
</div>
<p>
  The interesting items to note in the script is the use of the two modules Gimp and Gimp::Fu, 
  the register function, which will be described in detail below, and the way the control is handed over to Gimp module on line 9. 
  The use of the ":auto" statement makes perl automatically include all of the gimp PDB functions and constants into the perl name space.
</p>

<div class="subtitle">3. The GIMP PDB</div>
<p>
  Before going into the details of the Perl-Fu script, we will describe how to access the various the functionality of GIMP. 
  All functions known to GIMP are available through the procedural database (PDB). All the PDB functions may be called from perl, as will be seen below. 
  These PDB functions are either internal to gimp, or have been made available through a plug-in or a script extension, but as far as the caller is concerned there is no difference. 
  As we will see below, when a perl function is registered through the register function, it will appear in the PDB as well.
</p>
<p>
  Gimp/perl comes with a PDB browser available in <span class="filter">Xtns -&gt; PDB Explorer</span>. 
  (There is another PDB browser available in <span class="filter">Xtns -&gt; DB Browser</span> but the PDB Explorer is more suited for Perl users.) 
  This browser provides a way of seeing all the functions in the PDB, as well as their input and output parameters. 
  E.g. the PDB Explorer entry for gimp_image_new, which will be used in the example below looks like this:
</p>
<p><table><tr><td bgcolor=#e0e0e0>
<table>
<tr><th valign=top align=right>Name:</th><td bgcolor=#e0e0ff colspan=3>gimp_image_new</td></tr>
<tr><th valign=top align=right>Blurb:</th><td valign=top colspan=3>Creates a new Image with the specified with, height, and type</td></tr>
<tr>
<th valign=top align=right valign=top>In:</th><td valign=top>INT32</td><td valign=top>width</td><td valign=top>The width of the image</td>
</tr>
<tr>
<th valign=top></th><td valign=top>INT32</td><td valign=top>height</td><td valign=top>The height of the image</td>
</tr>
<tr>
<th valign=top></th><td valign=top>INT32</td><td valign=top>type</td><td valign=top>The type of image { RGB (0), GRAY (1), INDEXED (2)</td>
</tr>
<tr><th valign=top align=right>Out:</th></tr><tr><td></td><td valign=top>IMAGE</td><td valign=top>image</td><td valign=top>The ID of the newly created image</td>
</tr>
<tr><th valign=top valign=top>Help:</th><td colspan=3>Creates a new image, undisplayed with the specified extents and type. A layer should be created and added before this image is displayed, 
or subsequent calls to 'gimp_display_new' with this image as an argument will fail. Layers can be created using the 'gimp_layer_new' commands. 
They can be added to an image using the 'gimp_image_add_layer' command</td></tr></table>
</table></p>
<p>
  All the the constants mentioned in the PDB Explorer have been defined within Gimp::Fu and may be used within perl. 
  E.g. I.e. a call to create a new image of size 100x150 of type RGB looks as follows:
</p>

<div class="code"><br />$img = gimp_image_new(100, 150, RGB)<br /></div>

<p>
  The PDB entry above shows that gimp_image_new is called with three parameters width, height, type. These are all of type INT32. This type and other types will be explained below.
  <br /><br />
  Script-Fu scripts are called just like any other script according to the PDB signature in the PDB browser. E.g. to run the Script Fu basic one logo just do:
</p>

<pre>script_fu_basic1_logo("Hello", 72,
                      "-*-utopia-*-r-*-*-72-*-*-*-*-*-*-*",
                      [0,0,0],[1,1,1]);</pre>
<p>
  Unfortunately, as of the writing, calling Script Fu from perl has proved a to make both ScriptFu and gimp very unstable and caused both of them to crash. 
  If any of the readers is able to describe what is needed to get it to run successfully, I will happily include this in a future version of this tutorial.
</p>
<p>
  <b>NOTE:</b> When calling a PDB function from Perl::Gimp that has an image and a drawable as the two first arguments, 
  only the drawable should be given as argument in the calling sequence.
</p>

<div class="subtitle">4. Gimp::Fu and the register function</div>
<p>
  Gimp-Fu is perl's answer to Script-Fu. It provides a simplified method for accepting parameters for a script through a Gtk interface, 
  just like script-fu, but as we shall see below, it has some additional bells and whistles.
   <br /><br />
  The main function for a Gimp-Fu script is the register function. This function declares the interface of the script to gimp. 
  The register function takes the following 10 parameters, that must all be provided:
</p>
<ol>
  <li>The name of the function - a string. This is the name of the function as it will be known in the PDB.</li>
  <li>A small description - a string</li>
  <li>A help text - a string</li>
  <li>The authors name - a string</li>
  <li>The copyright of the script - a string</li>
  <li>Creation date - a string</li>
  <li>Menu path - a string. The path has one of the two forms:
    <ol>
      <li>"&lt;Toolbox&gt;/Xtns/Perl-Fu/Script Name"</li>
      <li>"&lt;Image&gt;/Perl-Fu/Script Name"</li>
    </ol>
     If form 1. is given, then the script is a standalone script that appears in the menu hierarchy under Xtns/Perl-Fu and takes 
     all its inputs through the Gimp::Fu interface frame. If form 2. is given on the other hand, then the script is tied to the 
     image menu popped up through the right hand button over any image. In this case Gimp::Fu will add as the first two parameters 
     to the script the image and the drawable active when the script was invoked.</li>
  <li>The acceptable image types - a string. This list contains a list of image types acceptable. 
  This field is only used for scripts that are in the "&lt;Image&gt;" hieararchy. Possible values are listed in the table below:
  <table>
  <tr><th bgcolor=#dfdfdf>value</th><th bgcolor=#dfdfdf>meaning</th></tr>
  <tr><td bgcolor=#dfdfee valign=top>*<td bgcolor=#dfdfee valign=top>Any images are accepted</tr>
  <tr><td bgcolor=#dfdfee valign=top>RGB <td bgcolor=#dfdfee valign=top>RGB images</tr>
  <tr><td bgcolor=#dfdfee valign=top>RGBA <td bgcolor=#dfdfee valign=top>RGB images with alpha channels</tr>
  <tr><td bgcolor=#dfdfee valign=top>GREY <td bgcolor=#dfdfee valign=top>Grey level images</tr>
  </table></li>
  
  <li>Parameters - A reference to an array of parameters. (A reference to an array in perl is simply an array written within square brackets). 
  Each parameter in turn is a reference to an array containg the following four or five values:
  <ol>
<li> The type of the parameter. The types recognized by Gimp::Fu and their perl are given in the following table:
  <table>
   <tr><th bgcolor=#dfdfdf>Type</th><th bgcolor=#dfdfdf width=30%>Possible forms</th>
   <th bgcolor=#dfdfdf width=50%>Comment</tr>
   <tr><td bgcolor=#dfdfee valign=top>PF_INT<br>
  PF_INT32<br>
  PF_INT16<br>
  PF_INT8<br><td bgcolor=#dfdfee valign=top>42<td bgcolor=#dfdfee valign=top>A number. PF_INT is a synonym to PF_INT32.</tr>
  <tr><td bgcolor=#dfdfee valign=top>PF_VALUE<br>
  PF_FLOAT<br><td bgcolor=#dfdfee valign=top>3.141<td bgcolor=#dfdfee valign=top>A floating point number.
  <tr><td bgcolor=#dfdfee valign=top>PF_TOGGLE<br>
  PF_BOOLEAN<td bgcolor=#dfdfee valign=top>0<br>1<td bgcolor=#dfdfee valign=top>A boolean value.
  <tr><td bgcolor=#dfdfee valign=top>PF_SLIDER<br>
  PF_SPINNER
  <td bgcolor=#dfdfee valign=top>An integer value through a slider and a spinner interface. The range parameter should be specified and is interpreted as minimum, maximum, and step, e.g. [0,100,1].
  <td bgcolor=#dfdfee valign=top><img src="tpix.gif" width=0>
  <tr><td bgcolor=#dfdfee valign=top>PF_FONT<td bgcolor=#dfdfee valign=top>-*-blippo-*-*-*-*-24-*-*-*-*-*-*-*<td bgcolor=#dfdfee valign=top>A font in X11 font format. This interface launches a font browser.
  <tr><td bgcolor=#dfdfee valign=top>PF_STRING<td bgcolor=#dfdfee valign=top>"A string"<td bgcolor=#dfdfee valign=top>A string</tr>
  <tr><td bgcolor=#dfdfee valign=top>PF_COLOR<br>
  PF_COLOUR<td bgcolor=#dfdfee valign=top>[255,127,0]<br>
  <tt>#ff7f00</tt>
  <td bgcolor=#dfdfee valign=top>A color may either be expressed as a reference to an array of three components, or as a hexadecimal triple, proceeded by the hash sign.</tr>
  <tr><td bgcolor=#dfdfee valign=top>PF_TOGGLE<td bgcolor=#dfdfee valign=top>0<br>1<td bgcolor=#dfdfee valign=top>A boolean toggle
  <tr><td bgcolor=#dfdfee valign=top>PF_IMAGE<td bgcolor=#dfdfee valign=top>-<td bgcolor=#dfdfee valign=top>An image
  <tr><td bgcolor=#dfdfee valign=top>PF_DRAWABLE<td bgcolor=#dfdfee valign=top>-<td bgcolor=#dfdfee valign=top>A drawable.
  <tr><td bgcolor=#dfdfee valign=top>PF_BRUSH<td bgcolor=#dfdfee valign=top><img src="tpix.gif" width=0><td bgcolor=#dfdfee valign=top>A brush
  <tr><td bgcolor=#dfdfee valign=top>PF_GRADIENT<td bgcolor=#dfdfee valign=top><img src="tpix.gif" width=0><td bgcolor=#dfdfee valign=top>A gradient
  <tr><td bgcolor=#dfdfee valign=top>PF_PATTERN<td bgcolor=#dfdfee valign=top><img src="tpix.gif" width=0><td bgcolor=#dfdfee valign=top>A pattern
  </table>
</li>
 <li>The name of the parameter - a string</li>
 <li>A help text for the parameter</li>
 <li>Default value for the parameter. This should be given in the form listed in the table above.</li>
 <li>An array defining allowed range for the value. This is only possible for PF_SLIDER and PF_SPINNER.</li>
 </ol>
 <li>A reference to an array of return types of the sub in the 11th parameter.</li>
 <li>The sub to be called - a reference to a sub . This subroutine will be called when the associated menu entry declared through the Menu path described above. 
  When the sub is called it is passed as arguments the list of parameters declared in field 9, declared above, and in the case of a "&lt;Image&gt;..." script, 
  the active image and layer as first and second parameters.
 <br />
  A reference to a sub in perl may be declared in two ways. Either by declaring a subroutine at a different place in the source file, 
  e.g. sub run and reference it by writing \&amp;run. An alternative way is to write it inline by simply writing:
  <br />
  <pre>sub { ($text, $color) = @_ ; ... }</pre>
  <br />
  The sub is expected not need to display a new image after it has created it. Instead it is expected to return the new image or images that were created in 
  accordance with the return types declared in parameter 10 of the register call described above. This behaviour has been added in order to be able to call the sub noninteractively. 
  More about that behaviour below.
 </li>
</ol>

<div class="subtitle">4.2 A commented script</div>
<p>
  The following Gimp::Fu script example shows the steps described in the previous section. 
  It registeres a script that takes two values, the size of the image and a color, and then produces an image of the requested size with the requested color. 
  Quite useless, but is shows the importent steps of how to register a script, how to create a new image, and how to access some PDB functions.
</p>
<div class="code">
  #!/usr/local/bin/perl -w
  use Gimp ":auto";
  use Gimp::Fu;
  sub img_uni {
      my ($size, $color) = @_;
      # Create a new image
      $img = gimp_image_new($size, $size, RGB);
      # Create a new layer
      $layer = gimp_layer_new($img, $size, $size, RGB,
                        "Layer 1", 100, NORMAL_MODE);
      # add the layer to the image
      gimp_image_add_layer($img, $layer, -1);
      # Set the background to the required color
      gimp_palette_set_background($color);
      # Paint the layer
      gimp_edit_fill($layer, BG_IMAGE_FILL);
      # Return the image
      return $img;
  }
  register
        "img_uni",                 # fill in name
        "Create a uniform image",  # a small description
        "A tutorial script",       # a help text
        "Dov Grobgeld",            # Your name
        "Dov Grobgeld (c)",        # Your copyright
        "1999-05-14",              # Date
        "&lt;Toolbox&gt;/Xtns/Perl-Fu/Tutorial/Img Uni",   # menu path
        "*",
        [ 
         [PF_INT,   "size", "Img size", 100],
         [PF_COLOR, "color", "Img color", [255,127,0]] 
        ],
        \&amp;img_uni;
  exit main();
</div>
<p>
  Most of these commands are directly copied out the PDB.
  <br /><br />
  This script shows the essential steps of producing a stand-alone script:
</p>
<table>
  <tr><th>line(s)</th><th>Description</th>
  <tr><td>10</td><td> Creating a new image.</td></tr>
  <tr><td>13-14</td><td> Creating one or more layers.</td></tr>
  <tr><td>17</td><td> Attaching the layer to the image. </td></tr>
  <tr><td>19-23</td><td> Do some painting operations in the layers. </td></tr>
  <tr><td>26</td><td> Return the image to the caller</td></tr>
  <tr><td> 29-42</td><td> Registration of the extension</td></tr>
</table>
<p>
  To test the script, save it in the directory <b>$HOME/.gimp-1.2/plug-ins</b>. It must then be made executable through the command:
  <br /><br />
  <b>chmod +x $HOME/.gimp-1.2/plug-ins/uni</b>
  <br /><br />
  Then start gimp. It is generally a good idea to test the syntax of the script with perl -c before starting gimp. 
  (A more official way to add scripts is to use the gimptool --install-bin command).
</p>
<p>
  <b>Note:</b> Due to a bug in gimp (verified for version 1.2) it is not possible to add scripts once gimp is running. 
  On the other hand, it is possible to change a script which has already been registered, as long as the parameters don't change.
</p>
<p class="images">
  <img src="uni-menu.png" alt=""/>
</p>
<p>
  The script is now accessible through the menu system through the <b>Xtns</b> top menu.
</p>
<p class="images">
  <img src="uni-entry.png" alt=""/>
</p>
<p>
  When choosing this menu entry the following screen is popped up.
</p>
<p class="images">
  <img src="uni-result.png" alt=""/>
</p>
<p>
  Choosing the default values creates result like image above.
</p>

<div class="subtitle">5. Object oriented syntax</div>
<p>
  Gimp::Fu provides an alternative object-oriented syntax for the image and the drawable commands. 
  Here is a table showing the procedural vs the object oriented syntax for a few commands:
</p>
<table>
    <tr><th bgcolor=#E0E0E0>procedural syntax
    <th bgcolor=#E0E0E0>object oriented syntax
    <tr><td bgcolor=#FFE0E0>gimp_image_add_layer($drw,-1);
    <td bgcolor=#FFE0E0>$img-&gt;add_layer($drw, -1);
    <tr><td bgcolor=#FFE0E0>gimp_drawable_width($drw);
    <td bgcolor=#FFE0E0>$drw-&gt;width();
</table>
<p>
  The substitution rule for converting a PDB turning into a method is as simple as erasing ``gimp_image_'' from the beginning of the function call 
  and calling this method through the image object. Similarly for the gimp_drawable_... functions.
  <br /><br />
  Note that the object oriented syntax is only syntactic sugar that makes the calling syntax cleaner in some cases. The error messages are still given in the procedural format.
</p>

<div class="subtitle">6. Painting areas with selections</div>
<p>
  In the uni script the function gimp_edit_fill was called to fill the whole image. Looking at the info for gimp_edit_fill in the DB browser we find the following:
</p>

<p>
<table><tr><td bgcolor=#e0e0e0>
<table>
<tr><th valign=top align=right>Name:</th><td bgcolor=#e0e0ff colspan=3>gimp_edit_fill</td></tr>
<tr><th valign=top align=right>Blurb:</th><td valign=top colspan=3>Fill selected area of drawable</td></tr>
<tr>
<th valign=top align=right valign=top>In:</th><td valign=top>DRAWABLE</td><td valign=top>drawable</td><td valign=top>The drawable to fill from</td>
</tr>
<tr>
<th valign=top></th><td valign=top>INT32</td><td valign=top>fill_type</td>
<td valign=top>The type of fill: FG_IMAGE_FILL (0), BG_IMAGE_FILL (1), WHITE_IMAGE_FILL (2), TRANS_IMAGE_FILL (3), NO_IMAGE_FILL (4)</td>
</tr>
<tr><th valign=top valign=top>Help:</th><td colspan=3>This procedure fills the specified drawable with the fill mode. If the fill mode is foreground, 
the current foreground color is used. If the fill mode is background, the current background color is used. Other fill modes should not be used. 
This procedure only affects regions within a selection if there is a selection active.</td></tr></table>
</table>
</p>

<p>
  Thus, if a selection is active when gimp_edit_fill is called only the selection is painted. 
  There are lots of ways of choosing a selection as can be seen when searching for a ``select'' in the PDB. 
  The example below uses gimp_rect_select, whose entry in the PDB looks as follows:
</p>

<p>
<table>
<tr><td bgcolor=#e0e0e0>
<table>
<tr><th valign=top align=right>Name:</th><td bgcolor=#e0e0ff colspan=3>gimp_rect_select</td></tr>

<tr><th valign=top align=right>Blurb:</th><td valign=top colspan=3>Create a rectangular selection over the specified image</td></tr>
<tr>
<th valign=top align=right valign=top>In:</th><td valign=top>IMAGE</td><td valign=top>image</td><td valign=top>The image</td>
</tr>
<tr>
<th valign=top></th><td valign=top>FLOAT</td><td valign=top>x</td><td valign=top>x coordinate of upper-left corner of rectangle</td>
</tr>
<tr>

<th valign=top></th><td valign=top>FLOAT</td><td valign=top>y</td><td valign=top>y coordinate of upper-left corner of rectangle</td>
</tr>
<tr>
<th valign=top></th><td valign=top>FLOAT</td><td valign=top>width</td><td valign=top>the width of the rectangle: width > 0</td>
</tr>
<tr>
<th valign=top></th><td valign=top>FLOAT</td><td valign=top>height</td><td valign=top>the height of the rectangle: width > 0</td>
</tr>

<tr>
<th valign=top></th><td valign=top>INT32</td><td valign=top>operation</td><td valign=top>the selection operation: {ADD (0), SUB(1), REPLACE (2), INTERSECT (3) }</td>
</tr>
<tr>
<th valign=top></th><td valign=top>INT32</td><td valign=top>feather</td><td valign=top>feather option for selections</td>
</tr>
<tr>
<th valign=top></th><td valign=top>FLOAT</td><td valign=top>feather_radius</td><td valign=top>radius for feather operation</td>
</tr>

<tr><th valign=top valign=top>Help:</th><td colspan=3>This tool creates a rectangular selection over the specified image. 
The rectangular region can be either added to, subtracted from, or replace the contents of the previous selection mask. 
If the feather option is enabled, the resulting selection is blurred before combining. The blur is a gaussian blur with the specified feather radius.
</td></tr></table>
</table>
</p>

<p>
  A simple use of this function which selects a rectangle in the middle of an image and paints that rectangle with a user defined color. 
  This example also introduces a couple of new features we haven't seen before:
</p>
<ul>
  <li>The script is associated with an image since its menu path starts with "&lt;Image&gt;/...". 
  Note that as a result of this the callback sub in line 13 receives two additional parameters, the active image and the seleced drawable.</li>
  <li>The use of a subroutine without a name as a parameter to register</li>
  <li>The use of the PDB functions gimp_undo_push_group_start  and gimp_undo_push_group_end. These functions declare an undo group. 
  When an undo is done on the image, instead of having the individual operators undo, all the actions between the undo start and the 
  undo group calls will be undone at once.</li>
  <li>The return type of the register function defines what new images should be displayed by gimp. 
  In this case we don't want to display any new images and therefore return an empty array.</li>
</ul>

<div class="code">
#!/usr/local/bin/perl -w
use Gimp ":auto";
use Gimp::Fu;
register
    "img_paint_select",
    "Paints the selection", "Paints the selection",
    "Dov Grobgeld", "Dov Grobgeld", "1999-05-14",
    "&lt;Image&gt;/Perl-Fu/Tutorial/Paint Select",
    "*",
    [
     [PF_COLOR, "color", "Rectangle color", [0,0,255]] ],
    sub {
        my($img, $layer, $color) = @_;
        my($width, $height) = (gimp_image_width($img),
                               gimp_image_height($img));
        # Select a rectangle inside the image and paint it with color
        gimp_undo_push_group_start($img);
        gimp_rect_select($img,
                         $width/4, $height/4, $width/2, $height/2,
                         REPLACE, 0,0);
        gimp_palette_set_background($color);
        gimp_edit_fill($layer, BG_IMAGE_FILL);
        gimp_selection_none($img);
        gimp_displays_flush();
        gimp_undo_push_group_end($img);
   # Tell gimp not to display a new image
   return ();
     };
exit main();
</div>
<p class="images">
  <img src="paint-select.png" alt=""/>
</p>
<p>
  The result when run on our previous image.
</p>

<div class="subtitle">6.1 Complex selections</div>
<p>
  Besides rectangular selections elliptical selections may also be created through the PDB functions 
  gimp_ellipse_select() and gimp_free_select() which allows the selection of ellipses and polygons.
  <br /><br />
  More complex selections may be created through the channel mechanism. The PDB gimp_channel_new() creates a new channel. 
  The channel is a drawable that may be painted into, just like any other drawable, but with the difference that it is always a grey level image. 
  Once the channel is finished, the channel may be loaded into the selection through the PDB function gimp_selection_load().
  <br /><br />
  Search for ``select'' in the DB Browser to see a list of all the selection related functions.
</p>

<div class="subtitle">6.2 Loops</div>
<p>
  In perl it is trivial to write loops that together with the various selecton tools gives powerful creative possibilities. 
  Here is an example that mixes colors in circles. There is nothing really new here, but it shows the power of the what we have described above.
</p>
<div class="code">
#!/usr/local/bin/perl
use Gimp ":auto";
use Gimp::Fu;
sub circles {
    my ($size, $bgcolor, $radius) = @_;
    # Create the background
    $img = gimp_image_new($size, $size, RGB);
    $layer = gimp_layer_new($img, $size, $size, RGB,
                            "Layer 1", 100, NORMAL_MODE);
    gimp_image_add_layer($layer, -1);
    gimp_palette_set_background($bgcolor);
    gimp_edit_fill($layer, BG_IMAGE_FILL);
    my $ncircles = int($size/$radius/2);
    for ($i=0; $i&lt;$ncircles; $i++) {
        for ($j=0; $j&lt;$ncircles; $j++) {
            # Be creative and mix colors
            $color = [$i*30, ($ncircles-$j)*25, ($i+$j)*15];
            # Select a circle
            gimp_ellipse_select($img,
                                $i*$radius*2, $j*$radius*2,
                                $radius*2, $radius*2,
                                REPLACE, 1, 0, 0);
            # Paint the color in the circle
            gimp_palette_set_background($color);
            gimp_edit_fill($layer, BG_IMAGE_FILL);
            gimp_selection_none($img);
        }
    }
    return $img;
}
# register the script
register "circles", "a loop", "a loop", "Dov", "Dov", "1999-05-14",
    "&lt;Toolbox&gt;/Xtns/Perl-Fu/Tutorial/Circles",
    "*",
    [
     [PF_INT32, "size", "Img size", 100],
     [PF_COLOR, "bg", "Background color", [40,180,60]],
     [PF_INT32, "radius", "Circle radius", 10]
    ],
    \&amp;circles;
exit main();
</div>
<p class="images">
  <img src="circles.png" alt=""/>
</p>
<p>
  The result.
</p>

</div>
<!--#include virtual="/includes/tutnavbar.inc" -->
    <div>
      <span id="footerleft">
        Tutorial &copy; 2002 <a href="mailto:user@host.org">Author Name</a>
      </span>
      <span id="footerright">
        <a href="mailto:webmaster@gimp.org">webmaster@gimp.org</a>
      </span>
    </div>

  </body>
</html>
